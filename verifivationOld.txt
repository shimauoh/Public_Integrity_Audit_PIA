import java.io.*;
import java.math.BigInteger;
import java.nio.file.*;
import java.util.*;

public class Verification_test {

    public static void main(String[] args) throws Exception {
        // Simulate a challenge from TPA
        String blockIndex = "2";
    
        // Load public parameters
        Map<String, BigInteger> publicKeys = readPublicKeys("public_keys.txt");
        BigInteger p = publicKeys.get("p");
        BigInteger alpha = publicKeys.get("alpha");
        BigInteger chi = publicKeys.get("chi");
        BigInteger q = publicKeys.get("q");
    
        // Load secret keys (delta, xi) from file
        Map<String, BigInteger> secretKeys = readSecretKeys("secret_keys.txt");
        BigInteger delta = secretKeys.get("delta");
        BigInteger xi = secretKeys.get("xi");
    
        // CSP side: Proof generation with timing
        long cspStart = System.nanoTime();
        BigInteger W_prime = simulateCSP(blockIndex, chi, p);
        BigInteger dataBlock = new BigInteger(readBlockFromFile("numeric_data_blocks.txt", blockIndex));
        writeProofToFile("csp_proof_output.txt", Integer.parseInt(blockIndex), dataBlock, chi, W_prime);  // Save proof
        long cspEnd = System.nanoTime();
    
        // TPA side: Load stored tag (W, gamma)
        Map<String, String[]> storedTags = readTagsFromCSV("Basic_block_signature.csv");
        String[] tag = storedTags.get(blockIndex);
        if (tag == null) {
            System.err.println("Block index not found in signature CSV.");
            return;
        }
        BigInteger W_stored = new BigInteger(tag[0]);
        BigInteger gamma_stored = new BigInteger(tag[1]);
    
        // TPA side: Load W′ from file
        Map<String, BigInteger> cspProof = readProofFromFile("csp_proof_output.txt");
        BigInteger W_prime_fromFile = cspProof.get("W_dash");
    
        // TPA side: Verification with timing
        long tpaStart = System.nanoTime();
        BigInteger gamma_prime = computeGammaPrime(W_prime_fromFile, delta, xi, q);
        long tpaEnd = System.nanoTime();
    // Compare W′ with stored W
if (!W_stored.equals(W_prime_fromFile)) {
    System.err.println("❗Mismatch between stored W and computed W′");
    System.err.println("Stored W : " + W_stored);
    System.err.println("W′ from file: " + W_prime_fromFile);
    return; // Abort verification
}
        // Output results with detailed information
        System.out.println("\n=== Verification Details ===");
        System.out.println("Block Index: " + blockIndex);
        System.out.println("W_prime from file: " + W_prime_fromFile);
        System.out.println("Delta (private key): " + delta);
        System.out.println("Xi (secret key): " + xi);
        System.out.println("Q (modulus): " + q);
        System.out.println("\nStored gamma: " + gamma_stored);
        System.out.println("Computed gamma': " + gamma_prime);
        
        if (gamma_stored.equals(gamma_prime)) {
            System.out.println("\n✔ Verification successful");
        } else {
            System.out.println("\n✘ Verification failed");
            System.out.println("Difference: " + gamma_stored.subtract(gamma_prime));
        }
    
        // Output time measurements
        System.out.println("\n=== Timing Measurements ===");
        System.out.println("CSP Time (proof generation): " + (cspEnd - cspStart) + " ns");
        System.out.println("TPA Time (verification): " + (tpaEnd - tpaStart) + " ns");
    }
    
    // Compute gamma′ = (W′ * delta + xi) mod q
    private static BigInteger computeGammaPrime(BigInteger W_prime, BigInteger delta, BigInteger xi, BigInteger q) {
        return W_prime.multiply(delta).add(xi).mod(q);
    }
    
    // Read secret keys from file
    private static Map<String, BigInteger> readSecretKeys(String filename) throws IOException {
        Map<String, BigInteger> keys = new HashMap<>();
        List<String> lines = Files.readAllLines(Paths.get(filename));
        for (String line : lines) {
            line = line.trim();
            if (!line.isEmpty() && line.contains("=")) {
                String[] parts = line.split("=", 2);
                keys.put(parts[0].trim(), new BigInteger(parts[1].trim()));
            }
        }
        return keys;
    }
    
    // CSP: W′ = H(data || chi) mod p
    private static BigInteger simulateCSP(String blockIndex, BigInteger chi, BigInteger p) throws IOException {
        String dataBlock = readBlockFromFile("numeric_data_blocks.txt", blockIndex);
        String concatenated = dataBlock.trim() + chi.toString();
        BigInteger hash = sha256ToBigInteger(concatenated);
        return hash.mod(p);
    }

    // Load public keys from file
    private static Map<String, BigInteger> readPublicKeys(String filename) throws IOException {
        Map<String, BigInteger> keys = new HashMap<>();
        List<String> lines = Files.readAllLines(Paths.get(filename));
        for (String line : lines) {
            line = line.trim();
            if (!line.isEmpty() && line.contains("=")) {
                String[] parts = line.split("=", 2);
                keys.put(parts[0].trim(), new BigInteger(parts[1].trim()));
            }
        }
        return keys;
    }

    // Read numeric data block from file
    private static String readBlockFromFile(String filename, String index) throws IOException {
        List<String> lines = Files.readAllLines(Paths.get(filename));
        int idx = Integer.parseInt(index);
        if (idx >= 0 && idx < lines.size()) {
            String line = lines.get(idx);
            // Extract the number after the colon
            String[] parts = line.split(":", 2);
            if (parts.length == 2) {
                return parts[1].trim();
            }
            throw new IllegalArgumentException("Invalid block format: " + line);
        } else {
            throw new IllegalArgumentException("Invalid block index");
        }
    }

    // Write CSP's generated proof to file
    public static void writeProofToFile(String filename, int blockIndex, BigInteger dataBlock, BigInteger chi, BigInteger W_dash) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filename))) {
            writer.write("blockIndex=" + blockIndex + "\n");
            writer.write("dataBlock=" + dataBlock.toString() + "\n");
            writer.write("chi=" + chi.toString() + "\n");
            writer.write("W_dash=" + W_dash.toString() + "\n");
        }
    }

    // Read CSP's proof from file
    public static Map<String, BigInteger> readProofFromFile(String filename) throws IOException {
        Map<String, BigInteger> values = new HashMap<>();
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.contains("=")) {
                String[] parts = line.split("=");
                if (parts.length == 2) {
                    String key = parts[0].trim();
                    String valueStr = parts[1].trim();
                    try {
                        BigInteger value = new BigInteger(valueStr);
                        values.put(key, value);
                    } catch (NumberFormatException e) {
                        // Skip non-numeric values like blockIndex or dataBlock
                    }
                }
            }
        }
        reader.close();
        return values;
    }
    
    // SHA-256 hash to BigInteger
    private static BigInteger sha256ToBigInteger(String input) {
        try {
            java.security.MessageDigest digest = java.security.MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(input.getBytes(java.nio.charset.StandardCharsets.UTF_8));
            return new BigInteger(1, hashBytes);
        } catch (Exception e) {
            throw new RuntimeException("SHA-256 hashing failed", e);
        }
    }

    // Read (W, gamma) tags from CSV
    private static Map<String, String[]> readTagsFromCSV(String filename) throws IOException {
        Map<String, String[]> tags = new HashMap<>();
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = br.readLine()) != null) {
                String[] parts = line.split(",");
                if (parts.length >= 3)
                    tags.put(parts[0].trim(), new String[]{parts[1].trim(), parts[2].trim()});
            }
        }
        return tags;
    }
}
